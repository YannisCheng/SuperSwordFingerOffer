# HashMap

> 参考：https://blog.csdn.net/u010297957/article/details/51974340


- HashMap是基于数组来实现哈希表的，数组就好比内存储空间，数组的index就好比内存的地址。

- HashMap中的每个记录就是数组中存储的一个Entry<K, V>对象(链)。

- HashMap的哈希函数为 f(key) = key.hashCode() & (table.length - 1);，这里简化了hashCode的优化部分，后面会继续说。

- HashMap冲突方法是：链地址法，即每个数组位置上(称为bucket)存放的实际上都是一个Entry链而不是单个对象。
  这表现在Entry对象都有一个属性next来指向链表的下一个Entry。
  JDK 1.8，默认链表超过8则使用(自建的)红黑树，使得可以保证O(logN)的时间复杂度。
  另外在1.8中最好让key实现Comparable因为红黑树使用自然顺序而不是equals()，否则它就需要用自己的比较算法。

- HashMap的装填因子：默认为0.75。

- 要保证数组长度是2的幂。



## HashMap特点

快速「存」、「取」

## Hash函数
函数由2部门构成：hash函数+冲突处理函数

###  特点：
1. 灵活

 哈希函数是一个映像，因此哈希函数的设定很灵活，
 只要使得任何关键字由此所得的哈希函数值都落在表长允许的范围之内即可。

2. 冲突

对不同的关键字可能得到同一哈希地址，即key1≠key2key1≠key2，而f(key1)=f(key2)f(key1)=f(key2) ，
这种现象称为「冲突(collision)」。
冲突只能尽量地少，而不能完全避免。因为，哈希函数是从关键字集合到地址集合的映像。
而通常关键字集合比较大，它的元素包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。
因此，在实现哈希表这种数据结构的时候不仅要设定一个“好”的哈希函数，而且要设定一种“处理冲突的方法”。

### 常见Hash函数

1. 直接寻址法
2. 数字分析法
3. 平方取中法
4. 折叠法
5. 随机数法
6. 除留取余法

### 处理冲突

1. 开放定址法
2. 再哈希法
3. 链地址法

### 查找分析2个条件

1. 平均查找长度。作为衡量哈希表的查找效率的量度。
2. 装填因子（哈希表的装满程度）:

    α=表中已填入的记录数/数哈希表的长度

 - α越小：发生冲突的可能性就越小。
 - α越大：代表着表中已填入的元素越多，再填入元素时发生冲突的可能性就越大。
   那么在查找时，给定值需要比较的关键字的个数就越多。
 
 
 哈希表的「平均查找长度」是装填因子α 的函数，而不是n 的函数。
 因此，不管n 多大，我们总是可以选择一个合适的装填因子以便将平均查找长度限定在一个范围内。
 （Java 中HashMap 的默认装填因子是「0.75」）
 

## Hash表

### Hash函数与Hash表关系

通过「哈希(Hash)函数」映射关系而形成的表称为「哈希表」。



根据设定的Hash函数 - H(key) 和处理冲突的方法，将一组关键字映象 到一个有限的连续的地址集（区间）上，
并以关键字在地址集中的象 作为记录在表中的存储位置，这样的映射表便称为Hash表。



### Hash表 和 HashMap 的关系

Hash表是一种逻辑数据结构，HashMap是Java中的一种数据类型。
数据类型HashMap通过代码实现了Hash表这种数据结构，并利用此结构实现了Map的功能。
去除value部分只看key部分就是一个 Hash表 了。

